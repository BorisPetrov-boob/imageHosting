# Copilot instructions for this repository

Краткие и практические указания для AI-агентов, работающих над этим репозиторием (статический хостинг изображений).

- **Проект**: легковесный фронтенд без бэкенда. Загрузки сохраняются в `localStorage` как Base64 data-URI (см. `js/storage.js`).
- **Ключевые файлы**: `js/upload.js` (загрузка/валидация/drag&drop), `js/storage.js` (сохранение/удаление/чтение), `js/images-list.js` (рендер списка), `js/images.json` (статический список для слайдшоу), `css/` (стили).

**Большая картина**:
- Приложение — статический сайт: нет сервера. Изображения сохраняются в `localStorage` под ключом `uploaded_images`. UI показывает список из `localStorage` и позволяет удалять элементы.
- На некоторых страницах используется `images.json` (список путей в `/images/`) для слайдшоу — это отдельный поток данных от пользовательских загрузок.

**Что важно знать при внесении изменений**:
- Не добавляйте предположений о сервере: текущая логика ожидает работу полностью на клиенте.
- `saveImage(name, URL, size)` в `js/storage.js` возвращает boolean; обработка ошибок показывает алерты и статус в UI. Если меняете способ хранения — обновите `getAllImages()` и код, который ожидает структуру `{id,name,url,size,date}`.
- Валидация загрузки реализована в `js/upload.js`: `MAX_FILE_SIZE = 5*1024*1024`, `ALLOWED_FILE_TYPES = ['image/jpeg','image/png','image/gif']`. При изменении расширьте и обновите сообщения в `showStatus()`.
- UI-обработчики используют глобальные функции и `DOMContentLoaded`. Будьте осторожны с областью видимости — многие функции вызываются из HTML (например `onclick="deleteImageById(...)"`).

**Паттерны и соглашения в проекте**:
- Файлы подключаются с ведущим `/` в `href`/`src` (например `/js/upload.js`), поэтому проект ожидает запуск из корня сервера; открытие `index.html` через `file://` может ломать `fetch('images.json')` или относительные пути.
- Простые глобальные функции (camelCase) вместо модулей/ESM. Не переводите всё в модули без тестирования страниц.
- Работа со строками: `url` в объектах изображений может быть очень длинной (base64); при рендере используется усечение до 50 символов.

**Интеграционные точки и побочные эффекты**:
- `js/upload.js` вызывает `saveImage(...)` и ожидает синхронного/асинхронного результата (в текущей реализации `saveImage` синхронен). Если вы сделаете `saveImage` асинхронной (например, сохранение на сервер), обновите обработчики, чтобы корректно ждать Promise.
- `images.json` загружается через `fetch('images.json')`; если перемещаете файл — обновите путь.

**Запуск и отладка (рекомендации)**:
- Запускайте простой статический сервер из корня репозитория, чтобы пути `/js/...` и `fetch('images.json')` работали корректно. Примеры команд (PowerShell):

```powershell
# если установлен Python
python -m http.server 8000

# или с помощью npm-пакета http-server
npx http-server . -p 8000
```

- Откройте `http://localhost:8000/` в браузере и проверяйте `localStorage` в DevTools (`Application -> Local Storage`) под ключом `uploaded_images`.

**Примеры изменений (быстро и безопасно)**:
- Добавление нового мета-поля к изображениям: обновите `saveImage()` чтобы включать поле, затем скорректируйте `createImageItem()` в `js/images-list.js`.
- Переход на серверное хранение: реализуйте новую версию `saveImage()` возвращающую Promise и обновите `handlerFiles()` в `js/upload.js` чтобы ждать результат; обновите UI состояния (`showStatus`).

**Чего не делать**:
- Не удаляйте глобальные имена функций, вызываемые из HTML, без одновременной правки HTML.
- Не меняйте формат данных в `localStorage` без миграции (например, добавления версии схемы), иначе пользователи потеряют доступ к ранее загруженным изображениям.

Если нужно — я могу:
- добавить тестовый сценарий запуска сервера и примеры CURL/JS для вызова новых эндпоинтов,
- помочь мигрировать хранение из `localStorage` на сервер с минимальными изменениями в UI.

Пожалуйста, скажите, какие разделы нужно детализировать или какие изменения вы планируете — обновлю инструкцию под ваш сценарий.
